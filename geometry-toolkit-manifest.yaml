apiVersion: apps/v1
kind: Deployment
metadata:
  name: geometry-toolkit  # Имя проекта
spec:
  replicas: 3  # Количество реплик
  selector:
    matchLabels:
      app: geometry-toolkit  # Метка для выбора подов приложения

  # Настройки стратегии обновления подов
  strategy:
    type: RollingUpdate  # Использование стратегии "RollingUpdate" позволяет обновлять поды постепенно, избегая полного перерыва в обслуживании.
    rollingUpdate:
      maxUnavailable: 1  # Установка 1 недоступного пода позволяет избежать ситуации, когда все поды одновременно обновляются.
      maxSurge: 1  # Новые поды создаются перед удалением старых.

  template:
    metadata:
      labels:
        app: geometry-toolkit
    spec:
      affinity:
        podAntiAffinity:  # Настройка для обеспечения отказоустойчивости путем размещения подов на разных нодах
          preferredDuringSchedulingIgnoredDuringExecution:  # Предпочтительное размещение подов на разных нодах
            - weight: 100  # Вес, указывающий на предпочтение размещения подов на разных нодах; чем выше вес, тем более приоритетно размещение.
              podAffinityTerm:
                labelSelector:
                  matchExpressions:
                    - key: app
                      operator: In
                      values:
                        - geometry-toolkit  # Используется для определения, какие поды проверяются на размещение
                topologyKey: "kubernetes.io/hostname"  # Ключ, который определяет, как поды должны размещаться на нодах; в данном случае - это хост-имя ноды.
      
      # Инициализационные контейнеры (основное приложение не запустится, пока инициализация не завершится)
      initContainers:  
        - name: init-myapp
          image: init-image:latest
          command: ["sh", "-c", "sleep 5"]  # Шаблон для времени инициализации; ToDo: заменить на реальную инициализацию.

      containers:
        - name: geometry-toolkit-container
          image: geometry-toolkit-image:latest
          resources:
            requests:
              memory: "128Mi"  # Минимальное количество памяти, необходимое для работы контейнера; это значение выбрано по условиям задачи
              cpu: "500m"  # Запрос ресурсов CPU, равный 0.5 CPU, чтобы покрыть пики потребления при инициализации;
                          # После инициализации приложение стабилизируется на уровне 0.1 CPU, но 0.5 CPU обеспечивает
                          # достаточный запас для обработки нагрузки в период старта.
            limits:
              memory: "128Mi"
              cpu: "1"

          # Проверка готовности контейнера(необходима для того, чтобы Kubernetes не отправлял трафик на под до тех пор, пока приложение не будет полностью инициализировано);
          # ToDo: Заменить на реальные значения.
          readinessProbe:  
            httpGet:
              path: /health  # Шаблон для конечной точки;
              port: 8080  # Шаблон для порта;
            initialDelaySeconds: 10  # Задержка перед первой проверкой готовности;
            periodSeconds: 5  # Интервал между последующими проверками готовности;
          
          # Тайм-ауты и задержки
          # ToDo: Заменить на реальные значения.
          startupProbe:  # Проверка на старт контейнера
            httpGet:
              path: /health # Шаблон для конечной точки;
              port: 8080  # Шаблон для порта;
            initialDelaySeconds: 15  # Задержка перед первой проверкой старта;
            periodSeconds: 10  # Интервал между последующими проверками старта
            failureThreshold: 3  # Количество неудачных проверок перед тем, как контейнер будет перезапущен

          # Настройка перезапуска контейнера при сбоях
          restartPolicy: Always  # Контейнер будет автоматически перезапущен в случае сбоя для того, чтобы поддерживать высокий уровень доступности приложения.
---
# Сетевые настройки
apiVersion: v1
kind: Service
metadata:
  name: geometry-toolkit-service
spec:
# Использование типа ClusterIP позволяет изолировать приложение от внешнего мира, обеспечивая доступ только изнутри кластера.
# Это повышает безопасность, так как только другие сервисы в кластере могут взаимодействовать с приложением.
# В случае необходимости можно изменить тип сервиса на NodePort или LoadBalancer для доступа из внешней сети.
  type: ClusterIP
  selector:
    app: geometry-toolkit
  
  # ToDo: Заменить на реальные значения.
  ports:
    - protocol: TCP
      port: 8080
      targetPort: 8080
